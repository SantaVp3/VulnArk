package repository

import (
	"errors"
	"strconv"
	"time"

	"gorm.io/gorm"
	"vulnark/internal/model"
)

// VulnerabilityRepository 漏洞仓储接口
type VulnerabilityRepository interface {
	Create(vulnerability *model.Vulnerability) error
	GetByID(id uint) (*model.Vulnerability, error)
	Update(vulnerability *model.Vulnerability) error
	Delete(id uint) error
	List(req *model.VulnerabilitySearchRequest) ([]*model.Vulnerability, int64, error)
	GetStats() (*model.VulnerabilityStats, error)
	UpdateStatus(id uint, status string, userID uint) error
	AssignToUser(id uint, assigneeID uint, assignerID uint) error
	GetByAssetID(assetID uint) ([]*model.Vulnerability, error)
	CreateAttachment(attachment *model.VulnerabilityAttachment) error
}

// vulnerabilityRepository 漏洞仓储实现
type vulnerabilityRepository struct {
	db *gorm.DB
}

// NewVulnerabilityRepository 创建漏洞仓储
func NewVulnerabilityRepository(db *gorm.DB) VulnerabilityRepository {
	return &vulnerabilityRepository{
		db: db,
	}
}

// Create 创建漏洞
func (r *vulnerabilityRepository) Create(vulnerability *model.Vulnerability) error {
	return r.db.Create(vulnerability).Error
}

// GetByID 根据ID获取漏洞
func (r *vulnerabilityRepository) GetByID(id uint) (*model.Vulnerability, error) {
	var vulnerability model.Vulnerability
	err := r.db.Preload("Asset").
		Preload("Discoverer").
		Preload("Assignee").
		Preload("OWASPCategory").
		Preload("Attachments").
		First(&vulnerability, id).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("漏洞不存在")
		}
		return nil, err
	}
	return &vulnerability, nil
}

// Update 更新漏洞
func (r *vulnerabilityRepository) Update(vulnerability *model.Vulnerability) error {
	return r.db.Save(vulnerability).Error
}

// Delete 删除漏洞
func (r *vulnerabilityRepository) Delete(id uint) error {
	return r.db.Delete(&model.Vulnerability{}, id).Error
}

// List 获取漏洞列表
func (r *vulnerabilityRepository) List(req *model.VulnerabilitySearchRequest) ([]*model.Vulnerability, int64, error) {
	var vulnerabilities []*model.Vulnerability
	var total int64

	query := r.db.Model(&model.Vulnerability{}).
		Preload("Asset").
		Preload("Discoverer").
		Preload("Assignee").
		Preload("OWASPCategory")

	// 搜索条件
	if req.Keyword != "" {
		query = query.Where("title LIKE ? OR description LIKE ? OR cve_id LIKE ? OR cnvd_id LIKE ?",
			"%"+req.Keyword+"%", "%"+req.Keyword+"%", "%"+req.Keyword+"%", "%"+req.Keyword+"%")
	}

	if req.SeverityLevel != "" {
		if level, err := strconv.Atoi(req.SeverityLevel); err == nil {
			query = query.Where("severity_level = ?", level)
		}
	}

	if req.Status != "" {
		query = query.Where("status = ?", req.Status)
	}

	if req.AssetID != "" {
		if assetID, err := strconv.ParseUint(req.AssetID, 10, 32); err == nil {
			query = query.Where("asset_id = ?", uint(assetID))
		}
	}

	if req.AssigneeID != "" {
		if assigneeID, err := strconv.ParseUint(req.AssigneeID, 10, 32); err == nil {
			query = query.Where("assignee_id = ?", uint(assigneeID))
		}
	}

	if req.DiscovererID != "" {
		if discovererID, err := strconv.ParseUint(req.DiscovererID, 10, 32); err == nil {
			query = query.Where("discoverer_id = ?", uint(discovererID))
		}
	}

	if req.OWASPCategoryID != "" {
		if owaspID, err := strconv.ParseUint(req.OWASPCategoryID, 10, 32); err == nil {
			query = query.Where("owasp_category_id = ?", uint(owaspID))
		}
	}

	// 日期范围
	if req.StartDate != "" {
		if startDate, err := time.Parse("2006-01-02", req.StartDate); err == nil {
			query = query.Where("discovered_at >= ?", startDate)
		}
	}

	if req.EndDate != "" {
		if endDate, err := time.Parse("2006-01-02", req.EndDate); err == nil {
			query = query.Where("discovered_at <= ?", endDate.Add(24*time.Hour-time.Second))
		}
	}

	// 获取总数
	if err := query.Count(&total).Error; err != nil {
		return nil, 0, err
	}

	// 分页
	offset := (req.Page - 1) * req.PageSize
	if err := query.Offset(offset).Limit(req.PageSize).Order("created_at DESC").Find(&vulnerabilities).Error; err != nil {
		return nil, 0, err
	}

	return vulnerabilities, total, nil
}

// GetStats 获取漏洞统计
func (r *vulnerabilityRepository) GetStats() (*model.VulnerabilityStats, error) {
	stats := &model.VulnerabilityStats{
		BySeverity:  make(map[string]int64),
		ByStatus:    make(map[string]int64),
		ByOWASP:     make(map[string]int64),
		ByAssetType: make(map[string]int64),
	}

	// 总数
	if err := r.db.Model(&model.Vulnerability{}).Count(&stats.Total).Error; err != nil {
		return nil, err
	}

	// 按严重程度统计
	var severityStats []struct {
		SeverityLevel int
		Count         int64
	}
	if err := r.db.Model(&model.Vulnerability{}).Select("severity_level, COUNT(*) as count").Group("severity_level").Scan(&severityStats).Error; err != nil {
		return nil, err
	}
	for _, stat := range severityStats {
		var level string
		switch stat.SeverityLevel {
		case 1:
			level = "严重"
		case 2:
			level = "高危"
		case 3:
			level = "中危"
		case 4:
			level = "低危"
		default:
			level = "未知"
		}
		stats.BySeverity[level] = stat.Count
	}

	// 按状态统计
	var statusStats []struct {
		Status string
		Count  int64
	}
	if err := r.db.Model(&model.Vulnerability{}).Select("status, COUNT(*) as count").Group("status").Scan(&statusStats).Error; err != nil {
		return nil, err
	}
	for _, stat := range statusStats {
		var status string
		switch stat.Status {
		case "new":
			status = "新建"
		case "processing":
			status = "处理中"
		case "fixed":
			status = "已修复"
		case "verified":
			status = "已验证"
		case "closed":
			status = "已关闭"
		default:
			status = "未知"
		}
		stats.ByStatus[status] = stat.Count
	}

	// 按OWASP分类统计
	var owaspStats []struct {
		Name  string
		Count int64
	}
	if err := r.db.Table("vulnerabilities v").
		Select("oc.name, COUNT(*) as count").
		Joins("LEFT JOIN owasp_categories oc ON v.owasp_category_id = oc.id").
		Where("oc.name IS NOT NULL").
		Group("oc.name").
		Scan(&owaspStats).Error; err != nil {
		return nil, err
	}
	for _, stat := range owaspStats {
		stats.ByOWASP[stat.Name] = stat.Count
	}

	// 按资产类型统计
	var assetTypeStats []struct {
		Type  string
		Count int64
	}
	if err := r.db.Table("vulnerabilities v").
		Select("a.type, COUNT(*) as count").
		Joins("LEFT JOIN assets a ON v.asset_id = a.id").
		Group("a.type").
		Scan(&assetTypeStats).Error; err != nil {
		return nil, err
	}
	for _, stat := range assetTypeStats {
		stats.ByAssetType[stat.Type] = stat.Count
	}

	// 最近7天趋势
	var trendStats []struct {
		Date  string
		Count int64
	}
	if err := r.db.Model(&model.Vulnerability{}).
		Select("DATE(discovered_at) as date, COUNT(*) as count").
		Where("discovered_at >= ?", time.Now().AddDate(0, 0, -7)).
		Group("DATE(discovered_at)").
		Order("date").
		Scan(&trendStats).Error; err != nil {
		return nil, err
	}
	for _, stat := range trendStats {
		stats.RecentTrend = append(stats.RecentTrend, model.VulnerabilityTrendItem{
			Date:  stat.Date,
			Count: stat.Count,
		})
	}

	return stats, nil
}

// UpdateStatus 更新漏洞状态
func (r *vulnerabilityRepository) UpdateStatus(id uint, status string, userID uint) error {
	updates := map[string]interface{}{
		"status":     status,
		"updated_at": time.Now(),
	}

	// 根据状态设置相应的时间戳
	switch status {
	case model.StatusProcessing:
		updates["assigned_at"] = time.Now()
	case model.StatusFixed:
		updates["fixed_at"] = time.Now()
	case model.StatusVerified:
		updates["verified_at"] = time.Now()
	case model.StatusClosed:
		updates["closed_at"] = time.Now()
	}

	return r.db.Model(&model.Vulnerability{}).Where("id = ?", id).Updates(updates).Error
}

// AssignToUser 分配漏洞给用户
func (r *vulnerabilityRepository) AssignToUser(id uint, assigneeID uint, assignerID uint) error {
	updates := map[string]interface{}{
		"assignee_id": assigneeID,
		"assigned_at": time.Now(),
		"status":      model.StatusProcessing,
		"updated_at":  time.Now(),
	}

	return r.db.Model(&model.Vulnerability{}).Where("id = ?", id).Updates(updates).Error
}

// GetByAssetID 根据资产ID获取漏洞列表
func (r *vulnerabilityRepository) GetByAssetID(assetID uint) ([]*model.Vulnerability, error) {
	var vulnerabilities []*model.Vulnerability
	err := r.db.Where("asset_id = ?", assetID).Find(&vulnerabilities).Error
	return vulnerabilities, err
}

// OWASPCategoryRepository OWASP分类仓储接口
type OWASPCategoryRepository interface {
	GetAll() ([]*model.OWASPCategory, error)
	GetByID(id uint) (*model.OWASPCategory, error)
}

// owaspCategoryRepository OWASP分类仓储实现
type owaspCategoryRepository struct {
	db *gorm.DB
}

// NewOWASPCategoryRepository 创建OWASP分类仓储
func NewOWASPCategoryRepository(db *gorm.DB) OWASPCategoryRepository {
	return &owaspCategoryRepository{
		db: db,
	}
}

// GetAll 获取所有OWASP分类
func (r *owaspCategoryRepository) GetAll() ([]*model.OWASPCategory, error) {
	var categories []*model.OWASPCategory
	err := r.db.Order("code").Find(&categories).Error
	return categories, err
}

// GetByID 根据ID获取OWASP分类
func (r *owaspCategoryRepository) GetByID(id uint) (*model.OWASPCategory, error) {
	var category model.OWASPCategory
	err := r.db.First(&category, id).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("OWASP分类不存在")
		}
		return nil, err
	}
	return &category, nil
}

// CreateAttachment 创建漏洞附件
func (r *vulnerabilityRepository) CreateAttachment(attachment *model.VulnerabilityAttachment) error {
	return r.db.Create(attachment).Error
}
